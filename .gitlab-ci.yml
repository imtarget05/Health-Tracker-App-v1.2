image: docker:24

stages:
  - test
  - semgrep
  - sonarqube
  - build
  - deploy
  - verify

variables:
  NODE_IMAGE: "node:18"
  BACKEND_DIR: "backend"
  IMAGE_NAME: "${CI_PROJECT_PATH}/backend"
  IMAGE_TAG: "${IMAGE_NAME}:${CI_COMMIT_SHORT_SHA}"
  # Required for docker:dind on GitLab shared runners
  DOCKER_DRIVER: "overlay2"
  DOCKER_TLS_CERTDIR: ""
  # NOTE: The pipeline will push images only when the following CI variables are set in GitLab
  # CI_REGISTRY - e.g. registry.gitlab.com
  # CI_REGISTRY_USER - username (prefer CI_JOB_TOKEN or a robot account)
  # CI_REGISTRY_PASSWORD - password or token (masked variable)

# Run backend tests
test-backend:
  image: ${NODE_IMAGE}
  stage: test
  before_script:
    - cd ${BACKEND_DIR}
    - npm ci --no-audit --no-fund
  script:
    - |
      if [ -n "${TEST_SCRIPT}" ]; then
        eval "${TEST_SCRIPT}"
      else
        npm test
      fi
  artifacts:
    when: always
    expire_in: 1h
    paths:
      - ${BACKEND_DIR}/coverage/
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - ${BACKEND_DIR}/node_modules/

# Semgrep security scan (SAST)
semgrep-scan:
  image: returntocorp/semgrep:latest
  stage: semgrep
  script:
    - semgrep --config auto
  allow_failure: false
  artifacts:
    when: always
    paths:
      - semgrep.log

# SonarQube (conditional)
sonarqube-scan:
  image: sonarsource/sonar-scanner-cli:latest
  stage: sonarqube
  script:
    - |
      if [ -n "$SONAR_HOST_URL" ] && [ -n "$SONAR_TOKEN" ]; then
        cd ${BACKEND_DIR}
        sonar-scanner \
          -Dsonar.projectKey=health-tracker-backend \
          -Dsonar.sources=. \
          -Dsonar.host.url=$SONAR_HOST_URL \
          -Dsonar.login=$SONAR_TOKEN
      else
        echo "SONAR_HOST_URL or SONAR_TOKEN not set; skipping SonarQube scan"
      fi
  only:
    - branches
  allow_failure: true

# Build Docker image and optionally push to registry if CI credentials provided
docker-build:
  image: docker:24
  stage: build
  services:
    - name: docker:24-dind
  script:
    - cd ${BACKEND_DIR}
    - docker build -t ${IMAGE_TAG} .
    - |
      if [ -n "$CI_REGISTRY" ] && [ -n "$CI_REGISTRY_USER" ] && [ -n "$CI_REGISTRY_PASSWORD" ]; then
        echo "Logging into registry ${CI_REGISTRY}"
        # use CI_JOB_TOKEN or a masked CI variable. Do NOT echo secrets.
        echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
        docker push ${IMAGE_TAG}
      else
        echo "Registry credentials not configured; built image will remain on runner only."
      fi
  artifacts:
    when: always
    paths:
      - ${BACKEND_DIR}/Dockerfile
  only:
    - branches
  needs:
    - job: test-backend
    - job: semgrep-scan
    - job: sonarqube-scan

# Manual k8s deploy (requires KUBE_CONFIG)
deploy-k8s:
  image: bitnami/kubectl:1.27
  stage: deploy
  when: manual
  script:
    - |
      if [ -z "$KUBE_CONFIG" ]; then
        echo "KUBE_CONFIG not set; skipping deploy"
        exit 0
      fi
      mkdir -p ~/.kube
      echo "$KUBE_CONFIG" > ~/.kube/config
      sed -e "s|REPLACE_IMAGE|${IMAGE_TAG}|g" k8s/ci/backend-deployment.yaml | kubectl apply -f -
      kubectl apply -f k8s/ci/backend-service.yaml
  only:
    - branches

# Verify deployment by running a short smoke test inside the cluster (requires KUBE_CONFIG)
smoke-test:
  image: bitnami/kubectl:1.27
  stage: verify
  script:
    - |
      if [ -z "$KUBE_CONFIG" ]; then
        echo "KUBE_CONFIG not set; skipping smoke-test"
        exit 0
      fi
      mkdir -p ~/.kube
      echo "$KUBE_CONFIG" > ~/.kube/config
      # Run a transient curl pod inside the cluster to call the service DNS name
      kubectl -n health run --rm --restart=Never --image=curlimages/curl curl-test -- /bin/sh -c "curl -sSf http://health-backend:5001/api/health"
  only:
    - branches
  when: manual
